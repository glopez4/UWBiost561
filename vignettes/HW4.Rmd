---
title: 'HW4'
author: "Gabby Lopez"
date: "2024-05-27"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{HW3}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
1B. The function 'compute_maximal_partial_clique14' identifies the maximal partial clique within a graph represented by an adjacency matrix, ensuring the edge density meets or exceeds a specified threshold ('alpha'). It performs input validation to ensure the matrix is symmetric, binary, and has appropriate dimensions, and 'alpha' is between 0.5 and 1. The function uses a breadth-first (BFS) strategy to explore and evaluate potential cliques, tracking the best clique found based on the density criteria. The result is a list containing the indices of the nodes in the best clique and the calculated edge density. The function 'compute_maximal partial_clique20' identifies the largest subset of nodes in a graph (represented by an adjacency matrix) that forms a partial clique with an edge density at least equal to a specified threshold ('alpha'). It validates the input matrix and 'alpha' value, ensuring the matrix is square, binary, and has a zero diagonal. The function uses a combinatorial approach to evaluate all possible subsets of nodes to find the maximal partial clique, optionally providing verbose output for debugging. The result is a list containing the indices of the nodes in the identified clique and its edge density.

1C. For 'compute_maximal_partial_clique20', the original author could extract the subset evaluation logic into a dedication function, which would make the main function more readable and separates the concerns clearly. They could also enhance the function documentation to explain the purpose of each step more clearly, especially the verbose checks and the early exit condition. Similar to my suggestions for 'compute_maximal_partial_clique20', the original author for 'compute_maximal_partial_clique14', the code for calculating the density of a set of nodes can be extracted into a dedicated function which would improve readability by making the main logic more concise and separating concerns. They could also provide more detailed comments and documentation to explain the purpose of each step, especially around the BFS logic and the criteria for updating the best clique, this would help future readers understand the flow and reasoning behind each part of the function.

1D.
```{r error=TRUE, warning=TRUE}
# compute_maximal_partial_clique20
library(testthat)
library(UWBiost561)

  # mock data for testing
  set.seed(10)
  sim <- generate_partial_clique(n = 10,
                                 clique_fraction = 0.5,
                                 clique_edge_density = 0.9)
  adj_mat <- sim$adj_mat
  alpha <- 0.9
  res <- compute_maximal_partial_clique20(
    adj_mat = adj_mat,
    alpha = alpha
  )

  # test that output is the correct type
  test_that("is correct type and range", {
    expect_true(is.list(res))
    expect_true(is.vector(res$clique_idx))
    expect_true(is.numeric(res$edge_density))
  # test that output is within the correct range
    expect_true(length(res$clique_idx) <= nrow(adj_mat))
    expect_true(all(res$clique_idx <= nrow(adj_mat)) && all(res$clique_idx > 0))
    expect_true(res$edge_density >= alpha && res$edge_density <= 1)
  })

  # test with a small adjacency matrix
  adj_mat <- matrix(c(1, 1, 0, 0, 0,
                      1, 1, 1, 0, 0,
                      0, 1, 1, 1, 0,
                      0, 0, 1, 1, 1,
                      0, 0, 0, 1, 1), nrow = 5, byrow = TRUE)
  alpha <- 0.6
  result <- compute_maximal_partial_clique20(adj_mat, alpha)
  test_that("small adjacency matrix", {
    expect_equal(result$clique_idx, c(1, 2, 3, 4))
    expect_equal(result$edge_density, 0.6)
  })

  # test with a larger adjacency matrix
  adj_mat <- matrix(0, nrow = 50, ncol = 50)
  diag(adj_mat) <- 1
  alpha <- 0.7
  result <- compute_maximal_partial_clique20(adj_mat, alpha)
  test_that("large adjacency matrix", {
    expect_equal(length(result$clique_idx), 1)
    expect_equal(result$edge_density, 1)
  })

  # test with adjacency matrix containing only 1s
  adj_mat <- matrix(1, nrow = 10, ncol = 10)
  diag(adj_mat) <- 1
  alpha <- 0.5
  result <- compute_maximal_partial_clique20(adj_mat, alpha)
  test_that("matrix of 1s", {
    expect_equal(result$clique_idx, 1:10)
    expect_equal(result$edge_density, 1)
  })

  # testing with an empty adjacency matrix
  adj_mat <- matrix(0, nrow = 10, ncol = 10)
  alpha <- 0.7
  result <- compute_maximal_partial_clique20(adj_mat, alpha)
  test_that("empty matrix", {
    expect_equal(result, list(clique_idx = numeric(0), edge_density = NA))
  })
```

```{r error=TRUE, warning=TRUE}
# compute_maximal_partial_clique14

  # mock data for testing
  set.seed(10)
  sim <- generate_partial_clique(n = 10,
                                 clique_fraction = 0.5,
                                 clique_edge_density = 0.9)
  adj_mat <- sim$adj_mat
  alpha <- 0.9
  res <- compute_maximal_partial_clique14(
    adj_mat,
    alpha
  )

  # test that output is the correct type
  test_that("is correct type and range", {
    expect_true(is.list(res))
    expect_true(is.vector(res$clique_idx))
    expect_true(is.numeric(res$edge_density))
  # test that output is within the correct range
    expect_true(length(res$clique_idx) <= nrow(adj_mat))
    expect_true(all(res$clique_idx <= nrow(adj_mat)) && all(res$clique_idx > 0))
    expect_true(res$edge_density >= alpha && res$edge_density <= 1)
  })

  # test with a small adjacency matrix
  adj_mat <- matrix(c(1, 1, 0, 0, 0,
                      1, 1, 1, 0, 0,
                      0, 1, 1, 1, 0,
                      0, 0, 1, 1, 1,
                      0, 0, 0, 1, 1), nrow = 5, byrow = TRUE)
  alpha <- 0.6
  result <- compute_maximal_partial_clique14(adj_mat, alpha)
  test_that("small adjacency matrix", {
    expect_equal(result$clique_idx, c(1, 2, 3, 4))
    expect_equal(result$edge_density, 0.6)
  })

  # test with a larger adjacency matrix
  adj_mat <- matrix(0, nrow = 50, ncol = 50)
  diag(adj_mat) <- 1
  alpha <- 0.7
  result <- compute_maximal_partial_clique14(adj_mat, alpha)
  test_that("large adjacency matrix", {
    expect_equal(length(result$clique_idx), 1)
    expect_equal(result$edge_density, 1)
  })

  # test with adjacency matrix containing only 1s
  adj_mat <- matrix(1, nrow = 10, ncol = 10)
  diag(adj_mat) <- 1
  alpha <- 0.5
  result <- compute_maximal_partial_clique14(adj_mat, alpha)
  test_that("matrix of 1s", {
    expect_equal(result$clique_idx, 1:10)
    expect_equal(result$edge_density, 1)
  })

  # testing with an empty adjacency matrix
  adj_mat <- matrix(0, nrow = 10, ncol = 10)
  alpha <- 0.7
  result <- compute_maximal_partial_clique14(adj_mat, alpha)
  test_that("empty matrix", {
    expect_equal(result, list(clique_idx = numeric(0), edge_density = NA))
  })
```
2A.
```{r}
library(UWBiost561)
set.seed(10)
data <- UWBiost561::generate_partial_clique(n = 10, 
                                            clique_fraction = 0.5,
                                            clique_edge_density = 0.95)

set.seed(10)
result1 <- UWBiost561::compute_maximal_partial_clique_master(
  adj_mat = data$adj_mat, 
  alpha = 0.95, 
  number = 11, 
  time_limit = 30
)
result1

set.seed(10)
result2 <- UWBiost561::compute_maximal_partial_clique11(
  adj_mat = data$adj_mat, 
  alpha = 0.95
)
result2

set.seed(10)
data <- UWBiost561::generate_partial_clique(n = 49, 
                                            clique_fraction = 0.5,
                                            clique_edge_density = 0.95)
set.seed(10)
result3 <- UWBiost561::compute_maximal_partial_clique_master(
  adj_mat = data$adj_mat, 
  alpha = 0.95, 
  number = 4, 
  time_limit = 2
)
result3

```
2C.
```{r}
UWBiost561::simulation(num_func=4, num_trials=3)
```
