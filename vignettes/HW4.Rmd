---
title: 'HW4'
author: "Gabby Lopez"
date: "2024-05-27"
output: 
  bookdown::html_document2:
    number_sections: false
    toc: true
    toc_float:
      toc_collapsed: true
    theme: united
vignette: >
  %\VignetteIndexEntry{BIOST 561: Homework 4}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
1B. The function 'compute_maximal_partial_clique14' identifies the maximal partial clique within a graph represented by an adjacency matrix, ensuring the edge density meets or exceeds a specified threshold ('alpha'). It performs input validation to ensure the matrix is symmetric, binary, and has appropriate dimensions, and 'alpha' is between 0.5 and 1. The function uses a breadth-first (BFS) strategy to explore and evaluate potential cliques, tracking the best clique found based on the density criteria. The result is a list containing the indices of the nodes in the best clique and the calculated edge density. The function 'compute_maximal partial_clique20' identifies the largest subset of nodes in a graph (represented by an adjacency matrix) that forms a partial clique with an edge density at least equal to a specified threshold ('alpha'). It validates the input matrix and 'alpha' value, ensuring the matrix is square, binary, and has a zero diagonal. The function uses a combinatorial approach to evaluate all possible subsets of nodes to find the maximal partial clique, optionally providing verbose output for debugging. The result is a list containing the indices of the nodes in the identified clique and its edge density.

1C. For 'compute_maximal_partial_clique20', the original author could extract the subset evaluation logic into a dedication function, which would make the main function more readable and separates the concerns clearly. They could also enhance the function documentation to explain the purpose of each step more clearly, especially the verbose checks and the early exit condition. Similar to my suggestions for 'compute_maximal_partial_clique20', the original author for 'compute_maximal_partial_clique14', the code for calculating the density of a set of nodes can be extracted into a dedicated function which would improve readability by making the main logic more concise and separating concerns. They could also provide more detailed comments and documentation to explain the purpose of each step, especially around the BFS logic and the criteria for updating the best clique, this would help future readers understand the flow and reasoning behind each part of the function.

1D.
```{r, error=TRUE}
# compute_maximal_partial_clique20
library(testthat)
library(UWBiost561)

  # mock data for testing
  set.seed(10)
  sim <- generate_partial_clique(n = 10,
                                 clique_fraction = 0.5,
                                 clique_edge_density = 0.9)
  adj_mat <- sim$adj_mat
  alpha <- 0.9
  res <- UWBiost561::compute_maximal_partial_clique_master(
        adj_mat = adj_mat,
        alpha = alpha,
        number = 20,
        time_limit = 30
      )

  # test that output is the correct type
  test_that("is list", {
    expect_true(is.list(res))
  })
  test_that("is a vector", {
    expect_true(is.vector(res$clique_idx))
  })
  test_that("density is numeric", {
    expect_true(is.numeric(res$edge_density))
  })
  test_that("is correct length", {
    expect_true(length(res$clique_idx) <= nrow(adj_mat))
  })
  test_that("is within range", {
    expect_true(all(res$clique_idx <= nrow(adj_mat)) && all(res$clique_idx > 0))
  })

```

```{r, error=TRUE}
# compute_maximal_partial_clique14

  # mock data for testing
  set.seed(10)
  sim <- generate_partial_clique(n = 10,
                                 clique_fraction = 0.5,
                                 clique_edge_density = 0.9)
  adj_mat <- sim$adj_mat
  alpha <- 0.9
  res <- UWBiost561::compute_maximal_partial_clique_master(
        adj_mat = adj_mat,
        alpha = alpha,
        number = 14,
        time_limit = 30
      )

  # test that output is the correct type
  test_that("is list", {
    expect_true(is.list(res))
  })
  test_that("is a vector", {
    expect_true(is.vector(res$clique_idx))
  })
  test_that("density is numeric", {
    expect_true(is.numeric(res$edge_density))
  })
  test_that("is correct length", {
    expect_true(length(res$clique_idx) <= nrow(adj_mat))
  })
  test_that("is within range", {
    expect_true(all(res$clique_idx <= nrow(adj_mat)) && all(res$clique_idx > 0))
  })


```
2A.
```{r}
library(UWBiost561)
set.seed(10)
data <- UWBiost561::generate_partial_clique(n = 10, 
                                            clique_fraction = 0.5,
                                            clique_edge_density = 0.95)

set.seed(10)
result1 <- UWBiost561::compute_maximal_partial_clique_master(
  adj_mat = data$adj_mat, 
  alpha = 0.95, 
  number = 11, 
  time_limit = 30
)
result1

set.seed(10)
result2 <- UWBiost561::compute_maximal_partial_clique11(
  adj_mat = data$adj_mat, 
  alpha = 0.95
)
result2

set.seed(10)
data <- UWBiost561::generate_partial_clique(n = 49, 
                                            clique_fraction = 0.5,
                                            clique_edge_density = 0.95)
set.seed(10)
result3 <- UWBiost561::compute_maximal_partial_clique_master(
  adj_mat = data$adj_mat, 
  alpha = 0.95, 
  number = 4, 
  time_limit = 2
)
result3

```
2B. The simulation is to evaluate and compare the performance of multiple functions designed to compute the maximal partial clique in a graph. The performance will be assessed across different values of edge density threshold ('alpha') and across multiple trials to ensure robustness. It uses the function 'generate_partial_clique' to generate random graphs. The random graphs are varied across different "levels" of the analysis by changing the edge density threshold ('alpha') and the random seed for each trial. By following this plan, you will be able to systematically evaluate the performance of different implementations of the maximal partial clique computation function across different conditions, ensuring a thorough and robust analysis.
```{r}
UWBiost561::partial_clique_simulation(num_func=4, num_trials=3)
```
2D.
```{r}
knitr::include_graphics('/Users/gabbylopez/Documents/BIOST 561/Homework/check1.png')
knitr::include_graphics('/Users/gabbylopez/Documents/BIOST 561/Homework/check2.png')
knitr::include_graphics('/Users/gabbylopez/Documents/BIOST 561/Homework/check3.png')
knitr::include_graphics('/Users/gabbylopez/Documents/BIOST 561/Homework/check4.png')
knitr::include_graphics('/Users/gabbylopez/Documents/BIOST 561/Homework/check5.png')
```

