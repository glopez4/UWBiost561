---
title: "HW2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{HW2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(bookdown)
library(rigr)
library(dplyr)
library(tidyverse)
library(ggplot2)
```
1A.
```{r}
country_population <- readr::read_csv("https://raw.githubusercontent.com/linnykos/561_s2024_public/main/HW2_files/country_population.csv")
country_population
country_birth <- readr::read_csv("https://raw.githubusercontent.com/linnykos/561_s2024_public/main/HW2_files/country_birth.csv")

options(scipen = 100)
country_population <- country_population %>%
  filter(year >= 1990 & year <= 2010) %>%
  group_by(iso3c, country) %>%
  summarize(mean_population = mean(population))
country_population
```
1B.
```{r}
country_birth <- country_birth %>% 
  filter(year >= 1990 & year <= 2010) %>%
  filter(!is.na(iso3c), !is.na(year), !is.na(life_expect)) %>%
  group_by(iso3c) %>%
  summarize(max_life_expect = max(life_expect), min_life_expect = min(life_expect)) %>%
  mutate(range_life_expect = max_life_expect - min_life_expect)
country_birth
```

1C. There are 202 rows and 6 columns in country_both.
```{r}
country_both <- inner_join(country_population, country_birth, join_by(iso3c))
tibble(country_both)
```

2A.
```{r fig.width=8, fig.height=5}
penguins <- readr::read_csv("https://raw.githubusercontent.com/linnykos/561_s2024_public/main/HW2_files/palmerpenguins.csv")


penguins %>%
  ggplot(aes(x = bill_depth_mm, y = bill_length_mm, col=species)) +
  geom_point() +
  labs(x = 'Bill Depth (mm)', y = 'Bill Length (mm)', title = paste("Relation among", nrow(penguins), "penguins")) + 
  scale_color_manual(values = c("Adelie" = "cornflowerblue", "Chinstrap" = "coral2", "Gentoo" = "goldenrod3"))
```

2B.
```{r fig.width=8, fig.height=5}
penguins %>%
  ggplot(aes(x = bill_depth_mm, y = bill_length_mm, col=species)) +
  geom_point(alpha=0.5) +
  facet_wrap(~species) +
  geom_smooth(method = "lm", se = FALSE) + 
  labs(x = 'Bill Depth (mm)', y = 'Bill Length (mm)', title = paste("Relation among", nrow(penguins), "penguins")) + 
  scale_color_manual(values = c("Adelie" = "cornflowerblue", "Chinstrap" = "coral2", "Gentoo" = "goldenrod3"))
```

3A. The generate_random_graph function creates a randomized adjacency matrix for a graph with a specific number of nodes, a set probability of edges, and an embedded clique. After checking if the arguments are correct, it generates a nxn matrix of 0s and 1s and then makes the matrix is symmetric. It forms a clique within the matrix which is a subset of nodes where every two distinct nodes are different and then randomizes the order of the nodes in the adjacency matrix while also computing the reverse order in order to revert back to the original matrix if necessary. Then is outputs a list with the randomized adjacency matrix and the reverse order of the nodes.
```{r}
source("https://raw.githubusercontent.com/linnykos/561_s2024_public/main/HW2_files/random_graph_functions.R")
set.seed(0)
result <- generate_random_graph(n = 20,
                                clique_fraction = 0.5,
                                density_low = 0.1)
adj_mat <- result$adj_mat
dim(adj_mat)
adj_mat[1:5,1:5]
```

3B. The pivot_longer_heatmap function converts an adjacency matrix into a long format suitable for creating heatmaps. It first converts the adjacency matrix into a tibble and assigns column names based on the node identifiers. It then reshapes the tibble from a wide format into a long format using pivto_longer() which reshapes the matrix such that each row represents an individual connection between two nodes X and Y. Then it renames the column names and outputs a long format of the adjacency matrix. This output basically just looks at each 'cell' in the adjaceny matrix and lists it's X and Y value as well as the value present in that cell.
```{r}
mat_long <- pivot_longer_heatmap(adj_mat)
mat_long
```

3C.
```{r fig.width=6, fig.height=6}
cols <- c("0" = "palegoldenrod", "1" = "coral2")
mat_long %>%
  ggplot(aes(x = X, y = Y, fill = factor(Value))) + geom_tile(color="white") +
  scale_fill_manual(values = cols) + coord_fixed(ratio = 1) + labs(x = "Column", y = "Row") +
  guides(fill = guide_legend(title = "Value"))
```

3D. The code below undoes the randomization initially applied to the original adjacency matrix and restores the nodes to their initial order. So adj_mat2 is the adjacency matrix in its original order.
```{r fig.width=6, fig.height=6}
adj_mat2 <- result$adj_mat[result$rev_order, result$rev_order]
mat_long2 <- pivot_longer_heatmap(adj_mat2)
mat_long2

cols <- c("0" = "palegoldenrod", "1" = "coral2")
mat_long2 %>%
  ggplot(aes(x = X, y = Y, fill = factor(Value))) + geom_tile(color="white") +
  scale_fill_manual(values = cols) + coord_fixed(ratio = 1) + labs(x = "Column", y = "Row") +
  guides(fill = guide_legend(title = "Value"))
```

4. In order to test this function I would use a few different methods. First, I would create a few adjacency matrices where the maximal clique can be easily verified by hand and run them through the function to compare the output to the expected result, this would include matrices with a number of variations of cliques including matrices with no cliques. I would also run random matrices through the function that have predetermined clique properties to compare the functions output to the expected result. I would also test extreme scenarios, such as really sparse, dense, or large matrices to see how it performs. And lastly, if there is already any known software that performs this function, I would compare the output from our function to the preexisting software for further verification.
